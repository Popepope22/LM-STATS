
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chatter Performance Tracker (With Response Time)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        @media print {
            .no-print { display: none !important; }
            .page-break-after { page-break-after: always; }
            body { font-size: 10pt; }
            * { -webkit-print-color-adjust: exact !important; color-adjust: exact !important; }
        }
        @media screen {
            .page-break-after { margin-bottom: 2rem; }
        }
        ::-webkit-scrollbar { height: 8px; width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body class="bg-white min-h-screen pb-20">

    <div class="container mx-auto p-4 max-w-7xl">
        
        <div class="mb-6 flex justify-between items-start">
            <div>
                <h1 class="text-3xl font-bold text-gray-900 mb-2">Chatter Performance Tracker</h1>
                <p class="text-gray-600">Track performance against targets (Revenue, Messages, Fans, PPVs, Response Time).</p>
            </div>
        </div>

        <div id="debug-banner" class="hidden mb-4 p-2 bg-blue-50 text-blue-800 text-xs font-mono border border-blue-200 rounded"></div>

        <div class="bg-gray-50 rounded-lg p-6 mb-6 no-print">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-gray-900">1. Upload CSV Files</h2>
                <span id="allocation-status" class="text-sm text-gray-600"></span>
            </div>
            <p class="text-sm text-gray-600 mb-4">Upload 1-4 CSV files (representing 2-hour quarters).</p>

            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2 flex items-center gap-2">Quarter 1 <span id="q1-status" class="text-xs"></span></label>
                    <input type="file" accept=".csv" id="file-q1" class="block w-full text-base px-3 py-2 border border-gray-300 rounded-md bg-white file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-[#5D5CDE] file:text-white hover:file:bg-[#4D4CCE]">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2 flex items-center gap-2">Quarter 2 <span id="q2-status" class="text-xs"></span></label>
                    <input type="file" accept=".csv" id="file-q2" class="block w-full text-base px-3 py-2 border border-gray-300 rounded-md bg-white file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-[#5D5CDE] file:text-white hover:file:bg-[#4D4CCE]">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2 flex items-center gap-2">Quarter 3 <span id="q3-status" class="text-xs"></span></label>
                    <input type="file" accept=".csv" id="file-q3" class="block w-full text-base px-3 py-2 border border-gray-300 rounded-md bg-white file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-[#5D5CDE] file:text-white hover:file:bg-[#4D4CCE]">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2 flex items-center gap-2">Quarter 4 <span id="q4-status" class="text-xs"></span></label>
                    <input type="file" accept=".csv" id="file-q4" class="block w-full text-base px-3 py-2 border border-gray-300 rounded-md bg-white file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-[#5D5CDE] file:text-white hover:file:bg-[#4D4CCE]">
                </div>
            </div>

            <div class="flex gap-3">
                <button id="process-btn" class="flex-1 bg-[#5D5CDE] hover:bg-[#4D4CCE] text-white font-semibold py-3 px-6 rounded-md transition duration-200">Process Files</button>
                <button id="clear-all-btn" onclick="clearAll()" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-3 px-6 rounded-md transition duration-200">Clear All</button>
            </div>
        </div>

        <div id="allocation-section" class="hidden no-print">
            <div class="bg-gray-50 rounded-lg p-6 mb-6">
                <h2 class="text-2xl font-semibold text-gray-900 mb-4">2. Allocate Chatters to Groups</h2>
                
                <div class="flex border-b border-gray-300 mb-6">
                    <button class="shift-tab px-6 py-3 font-semibold text-white bg-[#5D5CDE] rounded-t-lg" data-shift="1">Shift 1</button>
                    <button class="shift-tab px-6 py-3 font-semibold text-gray-600 hover:bg-gray-200 rounded-t-lg" data-shift="2">Shift 2</button>
                    <button class="shift-tab px-6 py-3 font-semibold text-gray-600 hover:bg-gray-200 rounded-t-lg" data-shift="3">Shift 3</button>
                </div>

                <div id="shift-1-content" class="shift-content">
                    <div class="mb-6">
                        <div class="flex gap-3 mb-4">
                            <input type="text" id="shift-1-group-name" placeholder="Group name (e.g., GROUP 1)" class="flex-1 px-4 py-2 text-base border border-gray-300 rounded-md bg-white text-gray-900">
                            <input type="text" id="shift-1-manager-name" placeholder="Manager name (e.g., JAO)" class="flex-1 px-4 py-2 text-base border border-gray-300 rounded-md bg-white text-gray-900">
                            <button onclick="addGroup(1)" class="bg-[#5D5CDE] hover:bg-[#4D4CCE] text-white font-semibold px-6 py-2 rounded-md transition duration-200">Add Group</button>
                        </div>
                        <div id="shift-1-groups" class="space-y-4"></div>
                    </div>
                    <div class="bg-white rounded-lg p-4">
                        <h4 class="font-semibold text-gray-900 mb-3">Unassigned Chatters</h4>
                        <div id="shift-1-unassigned" class="flex flex-wrap gap-2"></div>
                    </div>
                </div>

                <div id="shift-2-content" class="shift-content hidden">
                    <div class="mb-6">
                        <div class="flex gap-3 mb-4">
                            <input type="text" id="shift-2-group-name" placeholder="Group name (e.g., GROUP 1)" class="flex-1 px-4 py-2 text-base border border-gray-300 rounded-md bg-white text-gray-900">
                            <input type="text" id="shift-2-manager-name" placeholder="Manager name (e.g., JAO)" class="flex-1 px-4 py-2 text-base border border-gray-300 rounded-md bg-white text-gray-900">
                            <button onclick="addGroup(2)" class="bg-[#5D5CDE] hover:bg-[#4D4CCE] text-white font-semibold px-6 py-2 rounded-md transition duration-200">Add Group</button>
                        </div>
                        <div id="shift-2-groups" class="space-y-4"></div>
                    </div>
                    <div class="bg-white rounded-lg p-4">
                        <h4 class="font-semibold text-gray-900 mb-3">Unassigned Chatters</h4>
                        <div id="shift-2-unassigned" class="flex flex-wrap gap-2"></div>
                    </div>
                </div>

                <div id="shift-3-content" class="shift-content hidden">
                    <div class="mb-6">
                        <div class="flex gap-3 mb-4">
                            <input type="text" id="shift-3-group-name" placeholder="Group name (e.g., GROUP 1)" class="flex-1 px-4 py-2 text-base border border-gray-300 rounded-md bg-white text-gray-900">
                            <input type="text" id="shift-3-manager-name" placeholder="Manager name (e.g., JAO)" class="flex-1 px-4 py-2 text-base border border-gray-300 rounded-md bg-white text-gray-900">
                            <button onclick="addGroup(3)" class="bg-[#5D5CDE] hover:bg-[#4D4CCE] text-white font-semibold px-6 py-2 rounded-md transition duration-200">Add Group</button>
                        </div>
                        <div id="shift-3-groups" class="space-y-4"></div>
                    </div>
                    <div class="bg-white rounded-lg p-4">
                        <h4 class="font-semibold text-gray-900 mb-3">Unassigned Chatters</h4>
                        <div id="shift-3-unassigned" class="flex flex-wrap gap-2"></div>
                    </div>
                </div>

                <div class="flex gap-3 mt-6">
                    <button onclick="lockAllocations()" id="lock-allocations-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-6 rounded-md transition duration-200">Lock Allocations & View Report</button>
                    <button onclick="resetAllocations()" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-3 px-4 rounded-md transition duration-200">Reset All</button>
                </div>
            </div>
        </div>

        <div id="results" class="hidden">
            <div class="flex justify-between items-center mb-4 no-print">
                <h2 class="text-2xl font-semibold text-gray-900">Performance Results</h2>
                <div class="flex gap-3">
                    <button onclick="showAllocationSection()" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-md transition duration-200 no-print">Edit Allocations</button>
                    <button onclick="window.print()" class="bg-[#5D5CDE] hover:bg-[#4D4CCE] text-white font-semibold py-2 px-4 rounded-md transition duration-200">Print Report</button>
                </div>
            </div>
            <div id="results-container" class="space-y-8"></div>
        </div>

        <div id="error-container" class="hidden">
            <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                <p class="text-red-800 font-medium">Error</p>
                <p id="error-message" class="text-red-600 text-sm mt-1"></p>
            </div>
        </div>
    </div>

    <script>
        // --- DEFAULT TARGETS ---
        const DEFAULT_TARGETS = {
            messagesSent: 0,  // 55/hr * 2
            fansChatted: 0,    // 7.5/hr * 2
            ppvsSent: 0,       // ~15/hr * 2 (Estimate)
            ppvsOpen: 0,       // Daily target / 4 shifts
            revenue: 0,       // $140/hr * 2
            responseTime: 6     // Minutes (Lower is better)
        };

        // Data storage
        const quarterData = { q1: null, q2: null, q3: null, q4: null };
        let allChatters = [];
        let allModels = {};
        const shiftAllocations = { 1: { groups: [] }, 2: { groups: [] }, 3: { groups: [] } };
        let chatterModels = {};
        let selectedChattersForAssignment = [];
        let allocationsLocked = false;
        
        // Storage for user preferences
        let modelVisibility = {}; 
        let modelTargets = {};    

        // Helper: Parse Time Strings (Safe Version)
        // Converts "3m 20s", "1h", or "5" into Minutes (Float)
        function parseTimeDuration(timeStr) {
            if (!timeStr) return 0;
            timeStr = timeStr.toString().toLowerCase().trim();
            if (timeStr === '-' || timeStr === '') return 0;
            
            let minutes = 0;
            const h = timeStr.match(/(\d+)\s*h/);
            const m = timeStr.match(/(\d+)\s*m/);
            const s = timeStr.match(/(\d+)\s*s/);

            if (h) minutes += parseInt(h[1]) * 60;
            if (m) minutes += parseInt(m[1]);
            if (s) minutes += parseInt(s[1]) / 60;
            
            // Fallback for plain numbers
            if (!h && !m && !s && !isNaN(parseFloat(timeStr))) {
                minutes = parseFloat(timeStr);
            }
            return minutes;
        }

        // Helper: Format Minutes back to "3m 20s"
        function formatTimeDuration(totalMinutes) {
            if (totalMinutes === 0 || totalMinutes === undefined || totalMinutes === null) return "-";
            const m = Math.floor(totalMinutes);
            const s = Math.round((totalMinutes - m) * 60);
            if (m === 0 && s === 0) return "0m 0s";
            return `${m}m ${s}s`;
        }
        
        // ==========================================
        //   LOCAL STORAGE FUNCTIONS (New Save Feature)
        // ==========================================

        function saveState() {
            const state = {
                quarterData: quarterData,
                shiftAllocations: shiftAllocations,
                allocationsLocked: allocationsLocked,
                modelVisibility: modelVisibility,
                modelTargets: modelTargets,
                allChatters: allChatters,
                chatterModels: chatterModels
            };
            try {
                localStorage.setItem('chatterTrackerState', JSON.stringify(state));
                console.log("State saved to local storage.");
            } catch (e) {
                console.error("Error saving state to localStorage:", e);
                showCustomAlert('Error saving data locally. Your browser might be in private/incognito mode.');
            }
        }

        function clearSavedState() {
            localStorage.removeItem('chatterTrackerState');
            console.log("Saved state cleared from local storage.");
        }

        function loadState() {
            try {
                const storedState = localStorage.getItem('chatterTrackerState');
                if (storedState) {
                    const state = JSON.parse(storedState);
                    
                    // Restore main data structures
                    Object.assign(quarterData, state.quarterData);
                    Object.assign(shiftAllocations, state.shiftAllocations);
                    allocationsLocked = state.allocationsLocked || false;
                    Object.assign(modelVisibility, state.modelVisibility);
                    Object.assign(modelTargets, state.modelTargets);
                    
                    // Restore computed data
                    allChatters = state.allChatters || [];
                    chatterModels = state.chatterModels || {};
                    
                    if (allChatters.length > 0) {
                        // If data was loaded, update UI and initialize
                        document.getElementById('allocation-section').classList.remove('hidden');
                        
                        // Update file upload status checks for files that were "processed"
                        const quarters = ['q1', 'q2', 'q3', 'q4'];
                        quarters.forEach((q, i) => {
                            const statusEl = document.getElementById(`${q}-status`);
                            if (quarterData[q]) {
                                statusEl.textContent = '✓ LOADED';
                                statusEl.className = 'text-xs text-blue-600';
                            }
                        });
                        
                        // Also update lock button state
                        const lockBtn = document.getElementById('lock-allocations-btn');
                        if (allocationsLocked) {
                            lockBtn.textContent = 'Allocations Locked - View Report';
                            lockBtn.classList.add('opacity-50', 'cursor-not-allowed');
                            document.getElementById('results').classList.remove('hidden');
                            document.getElementById('allocation-section').classList.add('hidden');
                            // **FIX 2: Call generateReport() on reload if locked**
                            generateReport(); 
                        } else {
                            lockBtn.textContent = 'Lock Allocations & View Report';
                            lockBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                        }

                        initializeAllocation();
                        updateAllocationStatus();
                        showCustomAlert('Previous session data loaded successfully. CSV files need to be re-selected if you want to re-process.');
                    }
                }
            } catch (e) {
                console.error("Error loading state from localStorage:", e);
                localStorage.removeItem('chatterTrackerState'); // Clear corrupted state
                showCustomAlert('Error loading saved data. The stored data may be corrupted and was cleared.');
            }
        }

        // Parse CSV file
        function parseCSV(file) {
            return new Promise((resolve, reject) => {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: (results) => resolve(results.data),
                    error: (error) => reject(error)
                });
            });
        }

        // Process data from CSV
        function processData(data, quarterName) {
            const processed = {};
            
            // Auto-Detect Columns
            let revenueKey = null;
            let responseTimeKey = null;

            if (data.length > 0) {
                const keys = Object.keys(data[0]);
                
                // 1. Revenue Detection
                const priorities = ['sales', 'total net earnings', 'earnings', 'gross earnings'];
                for (const p of priorities) {
                    const found = keys.find(k => k.toLowerCase().trim() === p);
                    if (found) { revenueKey = found; break; }
                }
                if (!revenueKey) {
                    revenueKey = keys.find(k => k.toLowerCase().includes('sales')) || 
                                 keys.find(k => k.toLowerCase().includes('revenue'));
                }

                // 2. Response Time Detection
                // Look for "response time"
                responseTimeKey = keys.find(k => k.toLowerCase().includes('response time'));

                // Debug Info to help verify columns
                const debugEl = document.getElementById('debug-banner');
                let msg = `[${quarterName}] Revenue: ${revenueKey || '❌'} | Response: ${responseTimeKey || '❌'}`;
                if (debugEl.innerHTML === "") debugEl.classList.remove('hidden');
                if (!debugEl.innerHTML.includes(quarterName)) {
                    debugEl.innerHTML += (debugEl.innerHTML ? ' | ' : '') + msg;
                }
            }

            data.forEach(row => {
                const chatter = row['Employees'];
                const model = row['Creators'];
                
                // Extract Metrics
                const messagesSent = parseInt(row['Direct messages sent']) || 0;
                const ppvsSent = parseInt(row['Direct PPVs sent']) || 0;
                const ppvsOpen = parseInt(row['PPVs unlocked']) || 0;
                const fansChatted = parseInt(row['Fans chatted']) || 0;
                
                // Extract Revenue
                let revenue = 0;
                if (revenueKey && row[revenueKey]) {
                    const cleanVal = row[revenueKey].toString().replace(/[^0-9.-]+/g, "");
                    revenue = parseFloat(cleanVal);
                }
                if(isNaN(revenue)) revenue = 0;

                // Extract Response Time
                let responseTime = 0;
                let hasValidResponse = false;
                if (responseTimeKey && row[responseTimeKey]) {
                    const val = row[responseTimeKey].toString();
                    // Check for non-empty, non-dash values
                    if (val.trim() !== '-' && val.trim() !== '') {
                        responseTime = parseTimeDuration(val);
                        hasValidResponse = true;
                    }
                }

                if (!chatter || !model) return;

                const key = `${chatter}|||${model}`;
                if (!processed[key]) {
                    processed[key] = {
                        chatter,
                        model,
                        fansChatted,
                        messagesSent,
                        ppvsSent,
                        ppvsOpen,
                        revenue,
                        // Store time sums and counts for averaging
                        responseTimeSum: hasValidResponse ? responseTime : 0,
                        responseCount: hasValidResponse ? 1 : 0
                    };
                } else {
                    processed[key].fansChatted += fansChatted;
                    processed[key].messagesSent += messagesSent;
                    processed[key].ppvsSent += ppvsSent;
                    processed[key].ppvsOpen += ppvsOpen;
                    processed[key].revenue += revenue;
                    
                    if (hasValidResponse) {
                        processed[key].responseTimeSum += responseTime;
                        processed[key].responseCount += 1;
                    }
                }
            });
            return Object.values(processed);
        }

        // Color palette
        const modelColors = [
            { bg: 'bg-blue-50', border: 'border-blue-400', text: 'text-blue-900' },
            { bg: 'bg-green-50', border: 'border-green-400', text: 'text-green-900' },
            { bg: 'bg-purple-50', border: 'border-purple-400', text: 'text-purple-900' },
            { bg: 'bg-orange-50', border: 'border-orange-400', text: 'text-orange-900' },
            { bg: 'bg-pink-50', border: 'border-pink-400', text: 'text-pink-900' },
            { bg: 'bg-teal-50', border: 'border-teal-400', text: 'text-teal-900' },
            { bg: 'bg-indigo-50', border: 'border-indigo-400', text: 'text-indigo-900' },
            { bg: 'bg-rose-50', border: 'border-rose-400', text: 'text-rose-900' }
        ];

        function createChatterTable(chatter, modelsData, quarterLabels) {
            modelsData.sort((a, b) => a.model.localeCompare(b.model));
            
            const maxQuarters = 4;
            const allQuarterSlots = ['Q1', 'Q2', 'Q3', 'Q4'];
            const modelsPerRow = 3;
            const modelRows = [];

            for (let i = 0; i < modelsData.length; i += modelsPerRow) {
                modelRows.push(modelsData.slice(i, i + modelsPerRow));
            }

            let html = `
                <div class="bg-white rounded border border-gray-300 mb-2 break-inside-avoid shadow-sm">
                    <div class="bg-[#5D5CDE] text-white px-3 py-2 flex justify-center items-center relative">
                        <h4 class="text-lg font-bold text-center">${chatter}</h4>
                        <span class="text-xs opacity-75 absolute right-3">
                            ${modelsData.length} model${modelsData.length > 1 ? 's' : ''}
                        </span>
                    </div>
            `;

            modelRows.forEach((rowModels, rowIdx) => {
                while (rowModels.length < modelsPerRow) {
                    rowModels.push(null);
                }

                html += `
                    <div class="overflow-x-auto">
                        <table class="w-full text-xs table-fixed" style="border-collapse: separate; border-spacing: 0;">
                            <thead class="bg-gray-100">
                                <tr>
                `;
                
                // HEADER ROW
                rowModels.forEach((modelEntry, idx) => {
                    const colorIdx = (rowIdx * modelsPerRow + idx) % modelColors.length;
                    const color = modelColors[colorIdx];
                    
                    if (modelEntry) {
                        html += `<th rowspan="2" class="px-1 py-1 text-left font-bold text-sm ${color.text} ${color.bg} border-b border-l border-t ${color.border}" style="width: 10%; border-width: 2px; white-space: nowrap;">${modelEntry.model}</th>`;
                        html += `<th class="px-1 py-1 text-center font-bold text-yellow-800 italic bg-yellow-50 border-b border-t border-gray-300" style="width: 5%; border-width: 1px;">Target</th>`;
                        allQuarterSlots.forEach(q => {
                            html += `<th class="px-1 py-1 text-center font-semibold text-gray-700 ${color.bg} border-b border-t border-gray-300" style="width: 4.5%; border-width: 1px; white-space: nowrap;">${q}</th>`;
                        });
                        html += `<th class="px-1 py-1 text-center font-semibold text-gray-700 ${color.bg} border-b border-t border-r ${color.border}" style="width: 6.5%; border-width: 2px; white-space: nowrap;">Total</th>`;
                    } else {
                        html += `<th colspan="${maxQuarters + 3}" class="px-1 py-1 bg-gray-50 border-b border-gray-300" style="width: 33.33%; border-width: 1px;"></th>`;
                    }
                });

                html += `
                                </tr>
                            </thead>
                            <tbody>
                `;

                // METRICS DEFINITION - Including Response Time
                const metricKeys = [
                    { label: 'Fans chatted', key: 'fansChatted' },
                    { label: 'Messages sent', key: 'messagesSent' },
                    { label: 'PPVs sent', key: 'ppvsSent' },
                    { label: 'PPVs open', key: 'ppvsOpen' },
                    { label: 'Revenue', key: 'revenue', isCurrency: true },
                    { label: 'Avg Response', key: 'responseTimeSum', isTime: true } // Added Response Time
                ];

                metricKeys.forEach((metricDef, metricIdx) => {
                    const isLastMetric = metricIdx === metricKeys.length - 1;
                    const rowBg = metricIdx % 2 === 0 ? '' : 'bg-gray-50/50';
                    
                    html += `<tr class="${rowBg}">`;

                    rowModels.forEach((modelEntry, idx) => {
                        const colorIdx = (rowIdx * modelsPerRow + idx) % modelColors.length;
                        const color = modelColors[colorIdx];

                        if (modelEntry) {
                            const bottomBorder = isLastMetric ? `border-b ${color.border}` : '';
                            
                            const specificTargets = modelTargets[modelEntry.model] || DEFAULT_TARGETS;
                            // Map 'responseTimeSum' to the config key 'responseTime'
                            const targetKey = metricDef.isTime ? 'responseTime' : metricDef.key;
                            const targetValue = specificTargets[targetKey];
                            
                            html += `<td class="px-1 py-1 text-gray-600 ${color.bg} font-medium border-l ${color.border} ${bottomBorder}" style="border-left-width: 2px; ${isLastMetric ? 'border-bottom-width: 2px;' : ''} white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${metricDef.label}</td>`;
                            
                            let targetDisplay = targetValue;
                            if (metricDef.isCurrency) targetDisplay = `$${targetValue}`;
                            if (metricDef.isTime) targetDisplay = `< ${targetValue}m`;

                            html += `<td class="px-1 py-1 text-center text-gray-600 font-semibold italic bg-yellow-50 ${bottomBorder}" style="${isLastMetric ? 'border-bottom-width: 1px;' : ''}">${targetDisplay}</td>`;

                            let totalSum = 0;
                            let totalCount = 0;
                            
                            allQuarterSlots.forEach((quarterSlot, slotIdx) => {
                                const quarterIdx = quarterLabels.indexOf(quarterSlot);
                                let value = 0;
                                let rawValue = 0;
                                let isValidTime = false;
                                
                                if (quarterIdx >= 0 && modelEntry.quarters[quarterIdx]) {
                                    const qData = modelEntry.quarters[quarterIdx];
                                    
                                    if (metricDef.isTime) {
                                        // Logic for Time: Use stored Sum and Count to get Avg
                                        if (qData.responseCount > 0) {
                                            rawValue = qData.responseTimeSum / qData.responseCount; // Avg for this specific quarter
                                            isValidTime = true;
                                            totalSum += qData.responseTimeSum;
                                            totalCount += qData.responseCount;
                                        } else {
                                            rawValue = 0;
                                        }
                                    } else {
                                        // Logic for Numbers: Just Sum
                                        rawValue = qData[metricDef.key] || 0;
                                        totalSum += rawValue;
                                    }
                                    value = rawValue;
                                }

                                // Start Quarter-over-Quarter (QoQ) Logic
                                let prevValue = null;
                                if (slotIdx > 0) {
                                    // Check if the previous quarter slot had data in our processed list
                                    const prevQuarterSlot = allQuarterSlots[slotIdx - 1];
                                    const prevQuarterIdx = quarterLabels.indexOf(prevQuarterSlot); 
                                    
                                    if (prevQuarterIdx >= 0 && modelEntry.quarters[prevQuarterIdx]) {
                                        const prevQData = modelEntry.quarters[prevQuarterIdx];

                                        if (metricDef.isTime) {
                                            if (prevQData.responseCount > 0) {
                                                prevValue = prevQData.responseTimeSum / prevQData.responseCount;
                                            } else {
                                                // Treat no response data in previous Q as worst possible performance (high response time)
                                                prevValue = 999999; 
                                            }
                                        } else {
                                            prevValue = prevQData[metricDef.key] || 0;
                                        }
                                    }
                                }
                                // End QoQ Logic

                                let displayValue = value;
                                if (metricDef.isCurrency) displayValue = `$${value.toFixed(0)}`;
                                if (metricDef.isTime) {
                                    displayValue = isValidTime ? formatTimeDuration(value) : '-';
                                } else if (value === 0) {
                                    displayValue = '-';
                                }
                                
                                let textColor = 'text-gray-900';
                                let fontWeight = 'font-normal';
                                
                                // Coloring: Implemented Quarter-over-Quarter (QoQ) comparison
                                if (quarterIdx >= 0 && modelEntry.quarters[quarterIdx]) {
                                    
                                    // Rule 1: HIGHER IS BETTER metrics -> 0 is always Red (non-time only)
                                    if (!metricDef.isTime && value === 0) {
                                        textColor = 'text-red-600'; fontWeight = 'font-bold';
                                    } 
                                    
                                    // Rule 2: QoQ Comparison (only if we have a previous value to compare to)
                                    else if (slotIdx > 0 && prevValue !== null) {
                                        fontWeight = 'font-bold';

                                        if (metricDef.isTime) {
                                            // LOWER IS BETTER (Response Time)
                                            if (value > prevValue) {
                                                textColor = 'text-red-600'; // Worse (slower)
                                            } else if (value === prevValue) {
                                                textColor = 'text-yellow-600'; // Same
                                            } else {
                                                textColor = 'text-green-600'; // Better (faster)
                                            }
                                        } else {
                                            // HIGHER IS BETTER (Revenue, Msgs, Fans, PPVs)
                                            if (value > prevValue) {
                                                textColor = 'text-green-600'; // Better
                                            } else if (value === prevValue) {
                                                textColor = 'text-yellow-600'; // Same
                                            } else { // value < prevValue
                                                textColor = 'text-red-600'; // Worse
                                            }
                                        }
                                    }
                                }

                                html += `<td class="px-1 py-1 text-center ${textColor} ${fontWeight} ${color.bg} ${bottomBorder}" style="${isLastMetric ? 'border-bottom-width: 1px;' : ''} white-space: nowrap; vertical-align: middle;">
                                    ${displayValue}
                                </td>`;
                            });

                            // Total Column Calculation
                            let finalTotal = totalSum;
                            if (metricDef.isTime && totalCount > 0) {
                                finalTotal = totalSum / totalCount; // Weighted average for time
                            }

                            let displayTotal = finalTotal;
                            if (metricDef.isCurrency) displayTotal = `$${finalTotal.toFixed(2)}`;
                            if (metricDef.isTime) displayTotal = totalCount > 0 ? formatTimeDuration(finalTotal) : '-';

                            html += `<td class="px-1 py-1 text-center font-bold text-gray-900 ${color.bg} border-r ${color.border} ${bottomBorder}" style="border-right-width: 2px; ${isLastMetric ? 'border-bottom-width: 2px;' : ''} white-space: nowrap; overflow: hidden; text-overflow: ellipsis; vertical-align: middle;">${displayTotal}</td>`;
                        } else {
                            html += `<td colspan="${maxQuarters + 3}" class="px-1 py-1 bg-gray-50"></td>`;
                        }
                    });
                    html += `</tr>`;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                `;
            });

            html += `</div>`;
            return html;
        }

        // Main processing function
        async function processAllFiles() {
            const errorContainer = document.getElementById('error-container');
            const errorMessage = document.getElementById('error-message');
            const allocationSection = document.getElementById('allocation-section');
            document.getElementById('debug-banner').innerHTML = ""; 
            document.getElementById('debug-banner').classList.add('hidden');
            
            errorContainer.classList.add('hidden');
            
            try {
                const quarters = ['q1', 'q2', 'q3', 'q4'];
                const quarterLabels = [];
                
                for (let i = 0; i < quarters.length; i++) {
                    const fileInput = document.getElementById(`file-${quarters[i]}`);
                    const statusEl = document.getElementById(`${quarters[i]}-status`);
                    
                    if (fileInput.files.length > 0) {
                        const data = await parseCSV(fileInput.files[0]);
                        quarterData[quarters[i]] = processData(data, `Q${i+1}`);
                        quarterLabels.push(`Q${i + 1}`);
                        statusEl.textContent = '✓';
                        statusEl.className = 'text-xs text-green-600';
                    } else if (quarterData[quarters[i]]) {
                        quarterLabels.push(`Q${i + 1}`);
                        statusEl.textContent = '✓ LOADED'; // Loaded data status if file input is empty
                        statusEl.className = 'text-xs text-blue-600';
                    } else {
                        statusEl.textContent = '';
                    }
                }

                if (quarterLabels.length === 0) {
                    throw new Error('Please upload at least one CSV file');
                }

                const allChattersSet = new Set();
                quarters.forEach(q => {
                    if (quarterData[q]) {
                        quarterData[q].forEach(entry => {
                            allChattersSet.add(entry.chatter);
                        });
                    }
                });

                allChatters = Array.from(allChattersSet).sort();
                chatterModels = {};
                allModels = {};
                
                // Consolidate all model/chatter data and structure it for the report
                allChatters.forEach(chatter => {
                    const models = new Set();
                    quarters.forEach(q => {
                        if (quarterData[q]) {
                            quarterData[q].forEach(entry => {
                                if (entry.chatter === chatter) {
                                    models.add(entry.model);
                                }
                            });
                        }
                    });

                    allModels[chatter] = Array.from(models);
                    
                    chatterModels[chatter] = Array.from(models).map(model => {
                        const quarterValues = quarters.map((q, idx) => {
                            if (quarterData[q]) {
                                const found = quarterData[q].find(e => e.chatter === chatter && e.model === model);
                                return found || null;
                            }
                            return null;
                        }).filter((_, idx) => quarterData[quarters[idx]] !== null); // Filter to only keep processed quarters

                        return {
                            model: model,
                            quarters: quarterValues 
                        };
                    });
                });

                // Clear any existing allocations that might contain chatters not in the new data
                [1, 2, 3].forEach(shift => {
                    shiftAllocations[shift].groups.forEach(group => {
                        group.chatters = group.chatters.filter(c => allChatters.includes(c));
                    });
                });

                // If targets were loaded, ensure they only exist for current models
                const currentModelsSet = new Set(Object.values(allModels).flat());
                Object.keys(modelTargets).forEach(model => {
                    if (!currentModelsSet.has(model)) {
                        delete modelTargets[model];
                    }
                });

                updateAllocationStatus();
                initializeAllocation();
                allocationSection.classList.remove('hidden');
                document.getElementById('results').classList.add('hidden');

                // --- SAVE FEATURE ADDITION ---
                saveState();

            } catch (error) {
                console.error(error);
                errorMessage.textContent = error.message;
                errorContainer.classList.remove('hidden');
                allocationSection.classList.add('hidden');
            }
        }


        // ==========================================
        //   ALLOCATION/GROUP/UI FUNCTIONS (Fix 1 applied here)
        // ==========================================

        function updateAllocationStatus() {
            const assignedCount = [1, 2, 3].flatMap(shift => shiftAllocations[shift].groups.flatMap(g => g.chatters)).length;
            const totalChatters = allChatters.length;
            const statusText = assignedCount === totalChatters 
                ? `<span class="text-green-600 font-bold">${assignedCount}/${totalChatters} Assigned</span>`
                : `<span class="text-orange-600 font-bold">${assignedCount}/${totalChatters} Assigned</span>`;
            document.getElementById('allocation-status').innerHTML = statusText;
        }

        // **FIX 1: Reworked initializeAllocation to remove redundant/incorrect UI logic**
        function initializeAllocation() {
            [1, 2, 3].forEach(shift => {
                // Renders groups/unassigned chatters data structure for all shifts
                // Visibility is controlled exclusively by the tab click handler below
                renderGroups(shift);
            });
            // Default to Shift 1 tab. This click handles the initial visibility setup
            // and calls renderGroups(1) again for the visible shift.
            const shift1Tab = document.querySelector('.shift-tab[data-shift="1"]');
            if(shift1Tab) {
                shift1Tab.click();
            }
        }

        function renderGroups(shift) {
            const container = document.getElementById(`shift-${shift}-groups`);
            container.innerHTML = '';
            
            const groupList = shiftAllocations[shift].groups;
            if (groupList.length === 0) {
                container.innerHTML = '<p class="text-gray-500 text-sm">No groups defined for this shift.</p>';
                renderUnassignedChatters(shift);
                return;
            }

            groupList.forEach(group => {
                const chatterChips = group.chatters.map(c => {
                    const modelCount = (chatterModels[c] || []).length;
                    return `
                        <div class="flex items-center bg-gray-200 text-gray-800 text-xs px-2 py-1 rounded-full whitespace-nowrap group relative cursor-pointer" onclick="manageChatterModels(${shift}, ${group.id}, '${c}')">
                            <span class="mr-1">${c}</span>
                            <span class="text-gray-500 text-[10px] ml-auto">(${modelCount})</span>
                            <span class="absolute top-0 right-0 -mt-1 -mr-1 bg-red-500 text-white w-4 h-4 flex items-center justify-center rounded-full text-[10px] opacity-0 group-hover:opacity-100 transition-opacity" onclick="event.stopPropagation(); removeChatterFromGroup(${shift}, ${group.id}, '${c}')">
                                &times;
                            </span>
                        </div>
                    `;
                }).join('');

                const isAssignmentActive = currentAssignmentShift === shift && currentAssignmentGroupId === group.id;
                
                container.innerHTML += `
                    <div class="p-4 rounded-lg border ${isAssignmentActive ? 'border-green-600 bg-green-50' : 'border-gray-300 bg-white'}" data-group-id="${group.id}">
                        <div class="flex justify-between items-start mb-3">
                            <div>
                                <h4 class="font-bold text-gray-900">${group.name}</h4>
                                <p class="text-sm text-gray-600">Manager: ${group.manager}</p>
                            </div>
                            <div class="flex gap-2">
                                <button onclick="editGroup(${shift}, ${group.id})" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded">Edit</button>
                                <button onclick="deleteGroup(${shift}, ${group.id})" class="text-xs bg-red-100 hover:bg-red-200 text-red-700 px-3 py-1 rounded">Delete</button>
                            </div>
                        </div>
                        <div class="flex justify-between items-center mb-2">
                            <p class="text-sm font-medium text-gray-700">${group.chatters.length} Chatter${group.chatters.length !== 1 ? 's' : ''} Assigned</p>
                            <button onclick="assignChatterToGroup(${shift}, ${group.id})" class="text-xs bg-[#5D5CDE] hover:bg-[#4D4CCE] text-white px-3 py-1 rounded">
                                ${isAssignmentActive ? 'Cancel Assignment' : 'Add/Remove'}
                            </button>
                        </div>
                        <div class="flex flex-wrap gap-2 pt-2 border-t border-gray-200 min-h-[40px]">
                            ${group.chatters.length > 0 ? chatterChips : `<p class="text-gray-500 text-sm italic">No chatters in this group.</p>`}
                        </div>
                    </div>
                `;
            });

            renderUnassignedChatters(shift);
            updateAllocationStatus();
        }

        function addGroup(shift) {
            const groupNameInput = document.getElementById(`shift-${shift}-group-name`);
            const managerNameInput = document.getElementById(`shift-${shift}-manager-name`);
            const groupName = groupNameInput.value.trim();
            const managerName = managerNameInput.value.trim();

            if (!groupName || !managerName) {
                showCustomAlert('Group name and manager name cannot be empty.');
                return;
            }

            const group = { id: Date.now(), name: groupName, manager: managerName, chatters: [] };
            shiftAllocations[shift].groups.push(group);
            groupNameInput.value = '';
            managerNameInput.value = '';
            renderGroups(shift);
            // --- SAVE FEATURE ADDITION ---
            saveState();
        }

        function editGroup(shift, groupId) {
            const group = shiftAllocations[shift].groups.find(g => g.id === groupId);
            if (!group) return;

            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.id = 'edit-group-modal';
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">Edit Group</h3>
                    <div class="space-y-3">
                        <div>
                            <label for="modal-group-name" class="block text-sm font-medium text-gray-700">Group Name</label>
                            <input type="text" id="modal-group-name" value="${group.name}" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900">
                        </div>
                        <div>
                            <label for="modal-manager-name" class="block text-sm font-medium text-gray-700">Manager Name</label>
                            <input type="text" id="modal-manager-name" value="${group.manager}" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md bg-white text-gray-900">
                        </div>
                    </div>
                    <div class="flex justify-end gap-3 mt-5">
                        <button class="px-4 py-2 bg-gray-500 text-white hover:bg-gray-600 rounded" onclick="document.getElementById('edit-group-modal').remove()">Cancel</button>
                        <button class="px-4 py-2 bg-[#5D5CDE] text-white hover:bg-[#4D4CCE] rounded" onclick="confirmEditGroup(${shift}, ${group.id})">Save</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            document.getElementById('modal-group-name').focus();
        }

        function confirmEditGroup(shift, groupId) {
            const group = shiftAllocations[shift].groups.find(g => g.id === groupId);
            if (!group) return;

            const newName = document.getElementById('modal-group-name').value.trim();
            const newManager = document.getElementById('modal-manager-name').value.trim();

            if (!newName || !newManager) {
                showCustomAlert('Group name and manager name cannot be empty.');
                return;
            }

            group.name = newName;
            group.manager = newManager;

            document.getElementById('edit-group-modal').remove();
            renderGroups(shift);
            // --- SAVE FEATURE ADDITION ---
            saveState();
        }

        function deleteGroup(shift, groupId) {
            shiftAllocations[shift].groups = shiftAllocations[shift].groups.filter(g => g.id !== groupId);
            renderGroups(shift);
            // --- SAVE FEATURE ADDITION ---
            saveState();
        }

        function removeChatterFromGroup(shift, groupId, chatterName) {
            const group = shiftAllocations[shift].groups.find(g => g.id === groupId);
            if (group) {
                group.chatters = group.chatters.filter(c => c !== chatterName);
                renderGroups(shift);
                // --- SAVE FEATURE ADDITION ---
                saveState();
            }
        }

        let currentAssignmentShift = null;
        let currentAssignmentGroupId = null;

        function assignChatterToGroup(shift, groupId) {
            // Toggle assignment mode
            if (currentAssignmentShift === shift && currentAssignmentGroupId === groupId) {
                cancelAssignment(shift);
                return;
            }

            currentAssignmentShift = shift;
            currentAssignmentGroupId = groupId;
            selectedChattersForAssignment = [];
            renderGroups(shift);
            updateAssignmentBanner(shift);
            renderUnassignedChatters(shift);
        }

        function updateAssignmentBanner(shift) {
            const container = document.getElementById(`shift-${shift}-unassigned`);
            const existingBanner = document.getElementById('assignment-banner');
            if (existingBanner) existingBanner.remove();

            const group = shiftAllocations[shift].groups.find(g => g.id === currentAssignmentGroupId);
            if (!group) return;

            const assignedChatters = new Set();
            shiftAllocations[shift].groups.forEach(g => {
                g.chatters.forEach(c => assignedChatters.add(c));
            });
            const unassigned = allChatters.filter(c => !assignedChatters.has(c));
            const selectedCount = selectedChattersForAssignment.length;

            const banner = document.createElement('div');
            banner.id = 'assignment-banner';
            banner.className = 'bg-green-100 border-2 border-green-500 rounded-lg p-3 mb-3 space-y-3';
            banner.innerHTML = `
                <div class="flex justify-between items-center gap-4">
                    <div>
                        <p class="text-green-800 font-semibold">Assigning to "${group.name}"</p>
                        <p class="text-green-700 text-sm mt-1">Click chatters below to select (${selectedCount} selected)</p>
                    </div>
                    <div class="flex gap-2">
                        ${unassigned.length > 0 ? `<button onclick="selectAllUnassigned(${shift})" class="bg-blue-500 hover:bg-blue-600 text-white text-sm px-3 py-2 rounded-md">Select All (${unassigned.length})</button>` : ''}
                        ${selectedCount > 0 ? `<button onclick="deselectAll(${shift})" class="bg-orange-500 hover:bg-orange-600 text-white text-sm px-3 py-2 rounded-md">Clear</button>` : ''}
                        ${selectedCount > 0 ? `<button onclick="confirmAssignment(${shift})" class="bg-[#5D5CDE] hover:bg-[#4D4CCE] text-white font-semibold px-4 py-2 rounded-md">Assign ${selectedCount} Chatter${selectedCount > 1 ? 's' : ''}</button>` : ''}
                        <button onclick="cancelAssignment(${shift})" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold px-4 py-2 rounded-md">Cancel</button>
                    </div>
                </div>
                <div>
                    <input type="text" id="chatter-search-input-${shift}" oninput="renderUnassignedChatters(${shift})" placeholder="Type to search for a chatter..." class="w-full px-4 py-2 text-base border border-gray-300 rounded-md bg-white text-gray-900">
                </div>
            `;
            container.parentNode.insertBefore(banner, container);
            document.getElementById(`chatter-search-input-${shift}`).focus();
        }

        function cancelAssignment(shift) {
            currentAssignmentShift = null;
            currentAssignmentGroupId = null;
            selectedChattersForAssignment = [];
            const existingBanner = document.getElementById('assignment-banner');
            if (existingBanner) existingBanner.remove();
            renderGroups(shift);
            renderUnassignedChatters(shift);
        }

        function selectAllUnassigned(shift) {
            const assignedChatters = new Set();
            shiftAllocations[shift].groups.forEach(g => { g.chatters.forEach(c => assignedChatters.add(c)); });
            const unassigned = allChatters.filter(c => !assignedChatters.has(c));
            selectedChattersForAssignment = unassigned;
            renderUnassignedChatters(shift);
            updateAssignmentBanner(shift);
        }

        function deselectAll(shift) {
            selectedChattersForAssignment = [];
            renderUnassignedChatters(shift);
            updateAssignmentBanner(shift);
        }

        function toggleChatterSelection(chatterName, shift) {
            const index = selectedChattersForAssignment.indexOf(chatterName);
            if (index > -1) {
                selectedChattersForAssignment.splice(index, 1);
            } else {
                selectedChattersForAssignment.push(chatterName);
            }
            renderUnassignedChatters(shift);
            updateAssignmentBanner(shift);
        }

        function confirmAssignment(shift) {
            if (selectedChattersForAssignment.length === 0) {
                showCustomAlert('Please select at least one chatter to assign.');
                return;
            }

            const targetGroup = shiftAllocations[shift].groups.find(g => g.id === currentAssignmentGroupId);
            if (!targetGroup) return;

            // Remove selected chatters from all other groups in all shifts
            const chattersToMove = new Set(selectedChattersForAssignment);
            [1, 2, 3].forEach(s => {
                shiftAllocations[s].groups.forEach(g => {
                    if (g.id !== currentAssignmentGroupId || s !== shift) {
                        g.chatters = g.chatters.filter(c => !chattersToMove.has(c));
                    }
                });
            });

            // Add chatters to the target group, ensuring no duplicates within the target group
            selectedChattersForAssignment.forEach(c => {
                if (!targetGroup.chatters.includes(c)) {
                    targetGroup.chatters.push(c);
                }
            });

            // Clear assignment mode
            currentAssignmentShift = null;
            currentAssignmentGroupId = null;
            selectedChattersForAssignment = [];
            const existingBanner = document.getElementById('assignment-banner');
            if (existingBanner) existingBanner.remove();

            renderGroups(shift);
            // --- SAVE FEATURE ADDITION ---
            saveState();
        }

        // ==========================================
        // MANAGE MODELS & TARGETS MODAL
        // ==========================================

        function manageChatterModels(shift, groupId, chatterName) {
            const chatterModelsList = chatterModels[chatterName] || [];
            if (!modelVisibility[chatterName]) {
                modelVisibility[chatterName] = {};
            }
            const chatterPrefs = modelVisibility[chatterName];

            let modelsHTML = chatterModelsList.map((modelData, index) => {
                const modelName = modelData.model;
                const isVisible = chatterPrefs[modelName] === undefined ? true : chatterPrefs[modelName];
                const t = modelTargets[modelName] || DEFAULT_TARGETS;

                return `
                    <div class="bg-gray-50 p-3 rounded-md border border-gray-200">
                        <div class="flex justify-between items-center mb-2">
                            <label class="flex items-center gap-2 cursor-pointer select-none">
                                <input type="checkbox" class="form-checkbox h-5 w-5 text-[#5D5CDE] rounded model-visible-check" data-model-name="${modelName}" ${isVisible ? 'checked' : ''}>
                                <span class="text-gray-800 font-semibold">${modelName}</span>
                            </label>
                            <button onclick="toggleTargetEdit('target-edit-${index}')" class="text-xs bg-purple-100 hover:bg-purple-200 text-purple-700 px-2 py-1 rounded border border-purple-300"> 
                                📉 Configure Targets 
                            </button>
                        </div>
                        <div id="target-edit-${index}" class="hidden mt-2 pt-2 border-t border-gray-200 grid grid-cols-2 gap-2 text-xs">
                            <div class="col-span-2 mb-1 font-bold text-gray-500">Target per 2-Hr Quarter</div>
                            <div>
                                <label class="block text-gray-600">Messages</label>
                                <input type="number" class="w-full border border-gray-300 rounded px-1 py-1" id="t-msg-${index}" value="${t.messagesSent}">
                            </div>
                            <div>
                                <label class="block text-gray-600">Fans</label>
                                <input type="number" class="w-full border border-gray-300 rounded px-1 py-1" id="t-fan-${index}" value="${t.fansChatted}">
                            </div>
                            <div>
                                <label class="block text-gray-600">PPVs Sent</label>
                                <input type="number" class="w-full border border-gray-300 rounded px-1 py-1" id="t-ppvs-${index}" value="${t.ppvsSent}">
                            </div>
                            <div>
                                <label class="block text-gray-600">PPVs Open</label>
                                <input type="number" class="w-full border border-gray-300 rounded px-1 py-1" id="t-ppvo-${index}" value="${t.ppvsOpen}">
                            </div>
                            <div>
                                <label class="block text-gray-600">Revenue ($)</label>
                                <input type="number" class="w-full border border-gray-300 rounded px-1 py-1" id="t-rev-${index}" value="${t.revenue}">
                            </div>
                            <div>
                                <label class="block text-gray-600">Resp. Time (min)</label>
                                <input type="number" step="0.1" class="w-full border border-gray-300 rounded px-1 py-1" id="t-resp-${index}" value="${t.responseTime}">
                            </div>
                            <div class="col-span-2 text-center mt-2">
                                <button onclick="saveModelTargets('${modelName}', ${index})" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded text-sm transition duration-150">Save Targets</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.id = 'model-manage-modal';
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-lg max-w-xl w-full mx-4 overflow-y-auto max-h-[90vh]">
                    <h3 class="text-xl font-semibold text-gray-900 mb-2">Model Configuration for: <span class="text-[#5D5CDE]">${chatterName}</span></h3>
                    <p class="text-sm text-gray-600 mb-4">Select which models to include in ${chatterName}'s report and configure their individual performance targets.</p>
                    
                    <div class="space-y-4">
                        ${modelsHTML}
                    </div>

                    <div class="flex justify-end gap-3 mt-6">
                        <button class="px-4 py-2 bg-gray-500 text-white hover:bg-gray-600 rounded" onclick="document.getElementById('model-manage-modal').remove()">Close (Discard Visibility Changes)</button>
                        <button class="px-4 py-2 bg-[#5D5CDE] text-white hover:bg-[#4D4CCE] rounded" onclick="saveModelVisibility('${chatterName}')">Save Visibility & Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function toggleTargetEdit(id) {
            const el = document.getElementById(id);
            el.classList.toggle('hidden');
        }

        window.saveModelTargets = function(modelName, index) {
            const targets = {
                messagesSent: parseInt(document.getElementById(`t-msg-${index}`).value) || 0,
                fansChatted: parseInt(document.getElementById(`t-fan-${index}`).value) || 0,
                ppvsSent: parseInt(document.getElementById(`t-ppvs-${index}`).value) || 0,
                ppvsOpen: parseInt(document.getElementById(`t-ppvo-${index}`).value) || 0,
                revenue: parseFloat(document.getElementById(`t-rev-${index}`).value) || 0,
                responseTime: parseFloat(document.getElementById(`t-resp-${index}`).value) || 0
            };
            modelTargets[modelName] = targets;
            
            const saveBtn = document.querySelector(`#target-edit-${index} button.bg-purple-600`);
            const originalText = saveBtn.textContent;
            saveBtn.textContent = "Saved!";
            saveBtn.classList.add('bg-green-600');
            setTimeout(() => {
                saveBtn.textContent = originalText;
                saveBtn.classList.remove('bg-green-600');
            }, 1500);
            
            // --- SAVE FEATURE ADDITION ---
            saveState();
        }

        function saveModelVisibility(chatterName) {
            const prefs = {};
            document.querySelectorAll('.model-visible-check').forEach(checkbox => {
                prefs[checkbox.dataset.modelName] = checkbox.checked;
            });
            modelVisibility[chatterName] = prefs;
            document.getElementById('model-manage-modal').remove();
            
            // --- SAVE FEATURE ADDITION ---
            saveState();
            if(allocationsLocked) {
                generateReport();
            }
        }


        document.querySelectorAll('.shift-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const shift = parseInt(this.dataset.shift);
                document.querySelectorAll('.shift-tab').forEach(t => {
                    t.classList.remove('bg-[#5D5CDE]', 'text-white');
                    t.classList.add('text-gray-600');
                });
                this.classList.add('bg-[#5D5CDE]', 'text-white');
                this.classList.remove('text-gray-600');

                document.querySelectorAll('.shift-content').forEach(c => c.classList.add('hidden'));
                document.getElementById(`shift-${shift}-content`).classList.remove('hidden');

                // Re-render only the active shift to update assignment mode/etc.
                renderGroups(shift); 
                
                // Re-render unassigned list and check for assignment banner on tab change
                renderUnassignedChatters(shift);
                if (currentAssignmentShift === shift) {
                    updateAssignmentBanner(shift);
                } else {
                    const existingBanner = document.getElementById('assignment-banner');
                    if (existingBanner) existingBanner.remove();
                }
            });
        });

        function lockAllocations() {
            allocationsLocked = true;
            const lockBtn = document.getElementById('lock-allocations-btn');
            lockBtn.textContent = 'Allocations Locked - View Report';
            lockBtn.classList.add('opacity-50', 'cursor-not-allowed');

            generateReport();
            saveState();
        }

        function resetAllocations() {
            // Unassign all chatters from all groups in all shifts
            [1, 2, 3].forEach(shift => {
                shiftAllocations[shift].groups.forEach(group => {
                    group.chatters = [];
                });
                // Re-render the currently active shift to update UI
                const activeShiftTab = document.querySelector('.shift-tab.bg-[#5D5CDE]');
                if (activeShiftTab) {
                    renderGroups(parseInt(activeShiftTab.dataset.shift));
                }
            });
            // Update the status and save the state
            updateAllocationStatus();
            saveState();
            showCustomAlert('All chatters unassigned and groups emptied.');
        }

        function generateReport() {
            const resultsContainer = document.getElementById('results-container');
            const results = document.getElementById('results');
            const allocationSection = document.getElementById('allocation-section');
            resultsContainer.innerHTML = '';
            
            const quarters = ['q1', 'q2', 'q3', 'q4'];
            const quarterLabels = quarters.map((q, i) => quarterData[q] ? `Q${i + 1}` : null).filter(q => q);

            for (let shift = 1; shift <= 3; shift++) {
                if (shiftAllocations[shift].groups.length === 0) continue;

                let shiftHTML = `
                    <div class="page-break-after">
                        <div class="bg-gray-100 p-4 mb-4 rounded-lg border-2 border-gray-300">
                            <h3 class="text-2xl font-bold text-gray-800 mb-1">SHIFT ${shift} PERFORMANCE REPORT</h3>
                            <p class="text-gray-600">Chatter Group Breakdown</p>
                        </div>
                `;

                shiftAllocations[shift].groups.forEach(group => {
                    if (group.chatters.length === 0) return;

                    const safeFilename = group.name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '').toLowerCase();
                    const safeManagerName = group.manager.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '').toLowerCase();
                    const groupReportId = `shift-${shift}-group-${group.id}`;

                    shiftHTML += `
                        <div class="mb-6">
                            <h4 class="text-xl font-semibold text-gray-900 mb-3 p-2 bg-yellow-50 rounded border-l-4 border-yellow-400">
                                ${group.name} - Manager: ${group.manager}
                            </h4>
                    `;
                    
                    let chatterBuffer = '';
                    const chattersPerSection = 3; 

                    group.chatters.forEach((chatter, chatterIndex) => {
                        const allModelsData = chatterModels[chatter] || [];
                        const prefs = modelVisibility[chatter] || {};
                        
                        const visibleModels = allModelsData.filter(m => {
                            // Default is true if preference is not set
                            return prefs[m.model] === undefined ? true : prefs[m.model];
                        });

                        if (visibleModels.length > 0) {
                            chatterBuffer += createChatterTable(chatter, visibleModels, quarterLabels);
                        }

                        if ((chatterIndex + 1) % chattersPerSection === 0 || chatterIndex === group.chatters.length - 1) {
                            const sectionIndex = Math.floor(chatterIndex / chattersPerSection);
                            const sectionNumber = sectionIndex + 1;
                            const sectionId = `${groupReportId}-section-${sectionIndex}`;
                            const sectionFilename = `${safeFilename}_${safeManagerName}_section${sectionNumber}.png`;

                            shiftHTML += `<div id="${sectionId}" class="mb-4 p-3 bg-gray-100 rounded border border-gray-300">`;
                            shiftHTML += chatterBuffer;
                            shiftHTML += `
                                <div class="flex gap-2 justify-end no-print mt-2 -mr-1 -mb-1">
                                    <button onclick="downloadGroupImage(this, '${sectionId}', '${sectionFilename}')" class="bg-blue-500 hover:bg-blue-600 text-white text-xs font-semibold py-1 px-2 rounded"> Download Section ${sectionNumber} </button>
                                    <button onclick="copyGroupImage(this, '${sectionId}')" class="bg-green-500 hover:bg-green-600 text-white text-xs font-semibold py-1 px-2 rounded"> Copy Section ${sectionNumber} </button>
                                </div>
                            `;
                            shiftHTML += `</div>`;
                            chatterBuffer = '';
                        }
                    });

                    shiftHTML += `
                        </div>
                    </div>
                    `;
                });

                shiftHTML += `</div>`;
                resultsContainer.innerHTML += shiftHTML;
            }

            allocationSection.classList.add('hidden');
            results.classList.remove('hidden');
        }

        function generateGroupBlob(elementId) {
            return new Promise((resolve, reject) => {
                const element = document.getElementById(elementId);
                const originalBg = element.style.backgroundColor;
                const originalFontSize = element.style.fontSize;
                
                // Prepare element for screenshot
                element.style.backgroundColor = '#ffffff'; 
                element.style.fontSize = '18pt';

                const buttonsToHide = element.querySelectorAll('.no-print');
                buttonsToHide.forEach(btn => btn.style.display = 'none');

                html2canvas(element, { 
                    scale: 4, 
                    useCORS: true, 
                    window: window,
                    onclone: (clonedDoc) => {
                        const clonedElement = clonedDoc.getElementById(elementId);
                        clonedElement.style.backgroundColor = originalBg;
                        clonedElement.style.fontSize = '18pt';
                        clonedDoc.querySelectorAll('.no-print').forEach(btn => btn.style.display = 'none');
                    }
                }).then(canvas => {
                    // Restore original styles
                    element.style.backgroundColor = originalBg;
                    element.style.fontSize = originalFontSize;
                    buttonsToHide.forEach(btn => btn.style.display = '');

                    canvas.toBlob(blob => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('Failed to create Blob from canvas.'));
                        }
                    }, 'image/png');
                }).catch(reject);
            });
        }

        async function downloadGroupImage(buttonEl, elementId, filename) {
            const originalText = buttonEl.innerHTML;
            buttonEl.innerHTML = '...';
            buttonEl.disabled = true;
            try {
                const blob = await generateGroupBlob(elementId);
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            } catch (err) {
                console.error('Download error:', err);
                showCustomAlert('Could not download image. See console for details.');
            } finally {
                buttonEl.innerHTML = originalText;
                buttonEl.disabled = false;
            }
        }

        async function copyGroupImage(buttonEl, elementId) {
            if (!navigator.clipboard || !navigator.clipboard.write) {
                showCustomAlert('Clipboard API not supported or blocked in this browser.');
                return;
            }
            const originalText = buttonEl.innerHTML;
            buttonEl.innerHTML = '...';
            buttonEl.disabled = true;
            try {
                const blob = await generateGroupBlob(elementId);
                const item = new ClipboardItem({ 'image/png': blob });
                await navigator.clipboard.write([item]);
                showCustomAlert('Image copied to clipboard!');
            } catch (err) {
                console.error('Copy error:', err);
                showCustomAlert('Could not copy image. See console for details.');
            } finally {
                buttonEl.innerHTML = originalText;
                buttonEl.disabled = false;
            }
        }

        function showAllocationSection() {
            document.getElementById('allocation-section').classList.remove('hidden');
            document.getElementById('results').classList.add('hidden');
        }

        function showCustomAlert(message) {
            const existingAlert = document.getElementById('custom-alert');
            if (existingAlert) existingAlert.remove();
            
            const alertEl = document.createElement('div');
            alertEl.id = 'custom-alert';
            alertEl.className = 'fixed bottom-5 right-5 bg-gray-800 text-white px-4 py-3 rounded shadow-lg z-50 text-sm opacity-0 transition-opacity duration-300';
            alertEl.textContent = message;
            document.body.appendChild(alertEl);

            setTimeout(() => {
                alertEl.style.opacity = '1';
            }, 10);

            setTimeout(() => {
                alertEl.style.opacity = '0';
                setTimeout(() => alertEl.remove(), 300);
            }, 3000);
        }

        function renderUnassignedChatters(shift) {
            const container = document.getElementById(`shift-${shift}-unassigned`);
            const assignedChatters = new Set();
            shiftAllocations[shift].groups.forEach(group => {
                group.chatters.forEach(c => assignedChatters.add(c));
            });

            const unassigned = allChatters.filter(c => !assignedChatters.has(c));
            
            // Check if we are in assignment mode for this shift
            const isAssignmentMode = currentAssignmentShift === shift;
            
            // Search input is only present in assignment mode
            let searchTerm = '';
            if (isAssignmentMode) {
                const searchInput = document.getElementById(`chatter-search-input-${shift}`);
                searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
            }

            const filteredUnassigned = unassigned.filter(c => c.toLowerCase().includes(searchTerm));

            if (filteredUnassigned.length === 0) {
                if (searchTerm) {
                    container.innerHTML = `<p class="text-gray-500 text-sm">No chatters found matching "${searchTerm}"</p>`;
                } else {
                    container.innerHTML = '<p class="text-gray-500 text-sm">All chatters have been assigned</p>';
                }
                return;
            }
            
            container.innerHTML = filteredUnassigned.map(chatter => {
                const isSelected = selectedChattersForAssignment.includes(chatter);
                const baseClasses = "text-xs px-2 py-1 rounded-full whitespace-nowrap cursor-pointer transition-all duration-150";
                
                let chipClasses = "";
                let clickAction = "";

                if (isAssignmentMode) {
                    if (isSelected) {
                        chipClasses = "bg-green-600 text-white ring-2 ring-green-400";
                    } else {
                        chipClasses = "bg-gray-200 text-gray-800 hover:bg-gray-300";
                    }
                    clickAction = `onclick="toggleChatterSelection('${chatter}', ${shift})"`;
                } else {
                    chipClasses = "bg-gray-200 text-gray-800";
                    clickAction = ""; // Not clickable outside assignment mode
                }

                return `<span class="${baseClasses} ${chipClasses}" ${clickAction}>${chatter}</span>`;
            }).join(' ');
        }

        function clearAll() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-lg max-w-sm w-full mx-4">
                    <h3 class="text-lg font-semibold text-gray-900 mb-2">Confirm Clear All</h3>
                    <p class="text-gray-700 mb-4">Are you sure you want to clear ALL data, allocations, and targets? This action cannot be undone.</p>
                    <div class="flex justify-end gap-3">
                        <button class="px-4 py-2 bg-gray-500 text-white hover:bg-gray-600 rounded" onclick="this.closest('.fixed').remove()">Cancel</button>
                        <button class="px-4 py-2 bg-red-500 text-white hover:bg-red-600 rounded" onclick="confirmClearAll(); this.closest('.fixed').remove()">Clear All Data</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function confirmClearAll() {
            // Reset main data structures
            Object.assign(quarterData, { q1: null, q2: null, q3: null, q4: null });
            Object.assign(shiftAllocations, { 1: { groups: [] }, 2: { groups: [] }, 3: { groups: [] } });
            
            allocationsLocked = false;
            allChatters = [];
            allModels = {};
            chatterModels = {};
            modelVisibility = {};
            modelTargets = {};
            
            document.getElementById('lock-allocations-btn').textContent = 'Lock Allocations & View Report';
            document.getElementById('lock-allocations-btn').classList.remove('opacity-50', 'cursor-not-allowed');
            document.getElementById('allocation-section').classList.add('hidden');
            document.getElementById('results').classList.add('hidden');
            document.getElementById('error-container').classList.add('hidden');
            
            // Clear file inputs and status indicators
            const quarters = ['q1', 'q2', 'q3', 'q4'];
            quarters.forEach(q => {
                document.getElementById(`file-${q}`).value = '';
                document.getElementById(`${q}-status`).textContent = '';
            });

            updateAllocationStatus();
            initializeAllocation(); // Re-render empty groups

            // --- SAVE FEATURE ADDITION ---
            clearSavedState();
        }

        document.addEventListener('DOMContentLoaded', (event) => {
            document.getElementById('process-btn').addEventListener('click', processAllFiles);
            // --- SAVE FEATURE ADDITION: Load state on page load ---
            loadState(); 
            window.addEventListener('beforeunload', function (e) {
                // Check if any processed data exists (even if loaded from storage)
                if (allChatters.length > 0) { 
                    e.preventDefault();
                    e.returnValue = 'Are you sure you want to leave? Your progress is saved, but you will need to re-select CSV files if you wish to re-process.';
                }
            });
        });
    </script>
</body>
</html>
