// ... (The entire HTML and the start of the <script> block)

//     <script>
//         // Data storage
//         const quarterData = { /* ... */ };
//         // Allocation data
//         let allChatters = [];
//         let allModels = {};
//         const shiftAllocations = { /* ... */ };
//         let chatterModels = {};
//         let selectedChattersForAssignment = [];
//         let allocationsLocked = false;
//         // --- NEW: Drag and drop state ---
//         let draggedGroupId = null;
//         let draggedShift = null;

// ... (Existing functions: parseCSV, processData, groupByChatter, createChatterTable, hideModel, showAllModels, processAllFiles, updateAllocationStatus, initializeAllocation, lockAllocations, resetAllocations, confirmReset)


// --- Start of incomplete function ---
// Render unassigned chatters
function renderUnassignedChatters(shift) {
    const container = document.getElementById(`shift-${shift}-unassigned`);
    const assignedChatters = new Set();
    shiftAllocations[shift].groups.forEach(group => {
        group.chatters.forEach(c => assignedChatters.add(c));
    });

    const unassigned = allChatters.filter(c => !assignedChatters.has(c));
    // The search input element 'chatter-search-input-${shift}' is not in the HTML,
    // so we'll treat it as empty, and filterUnassigned will be the full unassigned list.
    const searchInput = document.getElementById(`chatter-search-input-${shift}`);
    const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
    const filteredUnassigned = unassigned.filter(c => 
        c.toLowerCase().includes(searchTerm)
    );

    if (filteredUnassigned.length === 0) {
        // --- COMPLETE LOGIC HERE ---
        if (searchTerm) {
            container.innerHTML = `<p class="text-gray-500 text-sm">No chatters found matching "${searchTerm}"</p>`;
        } else {
            container.innerHTML = '<p class="text-gray-500 text-sm">All chatters have been assigned for this shift.</p>';
        }
        return;
    }

    // Since a dedicated search/select mode variable wasn't present,
    // we assume the default is simply rendering draggable tags for assignment.
    
    container.innerHTML = filteredUnassigned.map(chatter => {
        // The data-chatter-name is crucial for the drag-and-drop `drop` function
        return `
            <div draggable="true"
                 ondragstart="drag(event, '${chatter}', ${shift})"
                 class="chatter-tag px-3 py-1 text-sm rounded-full bg-indigo-100 text-indigo-800 cursor-grab border border-indigo-300 hover:bg-indigo-200 transition duration-150"
                 data-chatter-name="${chatter}">
                ${chatter}
            </div>
        `;
    }).join('');
}
// --- End of incomplete function ---

// --- NEW REQUIRED FUNCTIONS FOR DRAG-AND-DROP & GROUPS ---

// Helper function to render an individual chatter tag
function renderChatterTag(chatterName, groupId, shift) {
    const totalModels = allModels[chatterName] ? allModels[chatterName].length : 0;
    return `
        <div draggable="true"
             ondragstart="drag(event, '${chatterName}', ${shift}, '${groupId}')"
             class="chatter-tag px-3 py-1 text-sm rounded-full bg-gray-100 text-gray-800 cursor-grab border border-gray-300 hover:bg-gray-200 transition duration-150 flex items-center gap-2"
             data-chatter-name="${chatterName}">
            <span>${chatterName}</span>
            <span class="text-xs text-gray-500 ml-1">(${totalModels} Model${totalModels !== 1 ? 's' : ''})</span>
            <button onclick="removeChatterFromGroup('${chatterName}', '${groupId}', ${shift})" 
                    class="text-red-500 hover:text-red-700 ml-1 text-base leading-none">&times;</button>
        </div>
    `;
}

// Render groups and their chatters
function renderGroups(shift) {
    const container = document.getElementById(`shift-${shift}-groups`);
    const groups = shiftAllocations[shift].groups;

    if (groups.length === 0) {
        container.innerHTML = '<p class="text-gray-500 text-sm italic">No groups defined for this shift. Click "Add Group" to begin.</p>';
        return;
    }

    container.innerHTML = groups.map(group => {
        const chatterTags = group.chatters.map(chatterName => 
            renderChatterTag(chatterName, group.id, shift)
        ).join('');
        
        const isLockedClass = allocationsLocked ? 'opacity-70 cursor-not-allowed' : 'hover:bg-red-600';
        const isLockedDisabled = allocationsLocked ? 'disabled' : '';

        return `
            <div id="${group.id}" ondragover="dragOver(event)" ondrop="drop(event, ${shift}, '${group.id}')"
                 class="group-container bg-white p-4 rounded-lg border-t-4 border-[#5D5CDE] shadow-md space-y-3">
                <div class="flex justify-between items-start border-b pb-2 mb-3">
                    <div>
                        <h3 class="text-lg font-bold text-gray-900">${group.name}</h3>
                        <p class="text-sm text-gray-600">Manager: ${group.manager}</p>
                    </div>
                    <div class="flex gap-2 items-center">
                        <span class="text-sm font-semibold text-gray-700">${group.chatters.length} Chatter${group.chatters.length !== 1 ? 's' : ''}</span>
                        <button onclick="removeGroup('${group.id}', ${shift})" 
                                class="bg-red-500 text-white font-semibold px-2 py-1 rounded-md transition duration-200 text-sm ${isLockedClass}"
                                ${isLockedDisabled}>
                            Remove Group
                        </button>
                    </div>
                </div>
                <div class="flex flex-wrap gap-2 min-h-[40px] bg-gray-50 p-2 rounded" 
                     ondragover="dragOver(event)" ondrop="drop(event, ${shift}, '${group.id}')">
                    ${chatterTags || '<p class="text-xs text-gray-400 italic">Drag chatters here</p>'}
                </div>
            </div>
        `;
    }).join('');
}

// Add a new group
function addGroup(shift) {
    if (allocationsLocked) {
        showCustomAlert('Allocations are locked. Please unlock to add groups.');
        return;
    }
    const nameInput = document.getElementById(`shift-${shift}-group-name`);
    const managerInput = document.getElementById(`shift-${shift}-manager-name`);
    const name = nameInput.value.trim();
    const manager = managerInput.value.trim();

    if (!name || !manager) {
        showCustomAlert('Group Name and Manager Name are required.');
        return;
    }

    const newGroup = {
        id: `group-${shift}-${Date.now()}`,
        name: name,
        manager: manager,
        chatters: []
    };

    shiftAllocations[shift].groups.push(newGroup);
    
    // Clear inputs and re-render
    nameInput.value = '';
    managerInput.value = '';
    renderGroups(shift);
}

// Remove a group
function removeGroup(groupId, shift) {
    if (allocationsLocked) {
        showCustomAlert('Allocations are locked. Please unlock to remove groups.');
        return;
    }
    const groups = shiftAllocations[shift].groups;
    const groupIndex = groups.findIndex(g => g.id === groupId);

    if (groupIndex !== -1) {
        const removedGroup = groups.splice(groupIndex, 1)[0];
        if (removedGroup.chatters.length > 0) {
            // Repopulate unassigned list if chatters were in the removed group
            renderUnassignedChatters(shift);
        }
        renderGroups(shift);
    }
}

// Remove a chatter from a group (moves them back to unassigned)
function removeChatterFromGroup(chatterName, groupId, shift) {
    if (allocationsLocked) {
        showCustomAlert('Allocations are locked. Please unlock to change assignments.');
        return;
    }
    const group = shiftAllocations[shift].groups.find(g => g.id === groupId);
    if (group) {
        group.chatters = group.chatters.filter(c => c !== chatterName);
        renderGroups(shift);
        renderUnassignedChatters(shift);
    }
}


// --- DRAG AND DROP HANDLERS ---
function drag(ev, chatterName, shift, sourceGroupId = null) {
    if (allocationsLocked) {
        ev.preventDefault();
        return;
    }
    ev.dataTransfer.setData("text/plain", chatterName);
    draggedGroupId = sourceGroupId; // Store the source group ID (or null if from unassigned)
    draggedShift = shift;
    ev.dataTransfer.effectAllowed = "move";
}

function dragOver(ev) {
    ev.preventDefault();
    ev.dataTransfer.dropEffect = "move";
}

function drop(ev, targetShift, targetGroupId) {
    ev.preventDefault();
    if (allocationsLocked) return;

    const chatterName = ev.dataTransfer.getData("text/plain");

    if (draggedShift !== targetShift) {
        showCustomAlert(`Cannot move chatter ${chatterName} between different shifts (Shift ${draggedShift} to Shift ${targetShift}).`);
        return;
    }

    // 1. Remove from source (if applicable)
    if (draggedGroupId) {
        removeChatterFromGroup(chatterName, draggedGroupId, targetShift);
    }

    // 2. Add to target group (if a group is the target)
    if (targetGroupId) {
        const targetGroup = shiftAllocations[targetShift].groups.find(g => g.id === targetGroupId);
        if (targetGroup && !targetGroup.chatters.includes(chatterName)) {
            targetGroup.chatters.push(chatterName);
        }
    } 
    // If the drop target is not a group (e.g., the unassigned container),
    // the chatter is already removed from its source group (if it had one)
    // and simply returns to the unassigned list (which happens automatically
    // when we re-render after the source removal).
    
    // 3. Re-render both areas
    renderGroups(targetShift);
    renderUnassignedChatters(targetShift);
}


// --- TAB LOGIC ---
document.addEventListener('DOMContentLoaded', () => {
    const shiftTabs = document.querySelectorAll('.shift-tab');
    const shiftContents = document.querySelectorAll('.shift-content');
    const processBtn = document.getElementById('process-btn');

    // Tab switching logic
    shiftTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const shift = tab.getAttribute('data-shift');

            shiftTabs.forEach(t => {
                t.classList.remove('text-white', 'bg-[#5D5CDE]');
                t.classList.add('text-gray-600', 'hover:bg-gray-200');
            });
            tab.classList.add('text-white', 'bg-[#5D5CDE]');
            tab.classList.remove('text-gray-600', 'hover:bg-gray-200');

            shiftContents.forEach(content => {
                content.classList.add('hidden');
            });
            document.getElementById(`shift-${shift}-content`).classList.remove('hidden');
        });
    });

    // Event listener for the main Process button
    processBtn.addEventListener('click', processAllFiles);
});

// --- REPORT GENERATION (Stubbed) ---
function generateReport() {
    const resultsContainer = document.getElementById('results-container');
    const allocationSection = document.getElementById('allocation-section');
    const resultsSection = document.getElementById('results');
    
    // Update button state
    document.getElementById('lock-allocations-btn').textContent = 'Allocations Locked - Generating Report...';
    document.getElementById('lock-allocations-btn').classList.add('opacity-50', 'cursor-not-allowed');
    updateAllocationStatus();

    // Hide allocation, show results
    allocationSection.classList.add('hidden');
    resultsSection.classList.remove('hidden');

    // Clear previous results
    resultsContainer.innerHTML = '';
    
    const quarterLabels = ['Q1', 'Q2', 'Q3', 'Q4'].filter((_, idx) => quarterData[`q${idx + 1}`] !== null);

    // Group results by Shift and then Group
    for (let shift = 1; shift <= 3; shift++) {
        const groups = shiftAllocations[shift].groups;

        if (groups.length === 0) continue; // Skip shifts with no groups

        let shiftHtml = `<div class="page-break-after">
            <h3 class="text-3xl font-extrabold text-[#5D5CDE] mb-6">Shift ${shift} Performance Report</h3>`;

        groups.forEach(group => {
            if (group.chatters.length === 0) return;

            shiftHtml += `<div class="mb-8">
                <div class="bg-gray-100 p-3 rounded-t-lg flex justify-between items-center" id="group-${group.id}">
                    <h4 class="text-xl font-bold text-gray-800">${group.name} - ${group.manager}</h4>
                    <button onclick="showAllModels('group-${group.id}')" class="bg-indigo-400 hover:bg-indigo-500 text-white font-semibold py-1 px-3 rounded-md transition duration-200 text-sm no-print">
                        Show All Hidden Models
                    </button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 p-4 bg-white border border-gray-300 rounded-b-lg chatter-wall">`;

            group.chatters.forEach(chatterName => {
                const modelsData = chatterModels[chatterName];
                if (modelsData && modelsData.length > 0) {
                    shiftHtml += createChatterTable(chatterName, modelsData, quarterLabels);
                }
            });

            shiftHtml += `</div></div>`; // Close group div and inner content
        });

        shiftHtml += `</div>`; // Close shift container
        resultsContainer.innerHTML += shiftHtml;
    }
}


// --- UTILITY FUNCTIONS ---
function clearAll() {
    // Reset file inputs
    document.getElementById('file-q1').value = '';
    document.getElementById('file-q2').value = '';
    document.getElementById('file-q3').value = '';
    document.getElementById('file-q4').value = '';

    // Clear statuses
    document.getElementById('q1-status').textContent = '';
    document.getElementById('q2-status').textContent = '';
    document.getElementById('q3-status').textContent = '';
    document.getElementById('q4-status').textContent = '';

    // Reset data
    quarterData.q1 = null;
    quarterData.q2 = null;
    quarterData.q3 = null;
    quarterData.q4 = null;
    allChatters = [];
    chatterModels = {};

    // Reset allocations
    confirmReset();

    // Hide sections and errors
    document.getElementById('allocation-section').classList.add('hidden');
    document.getElementById('results').classList.add('hidden');
    document.getElementById('error-container').classList.add('hidden');
}

function showAllocationSection() {
    document.getElementById('results').classList.add('hidden');
    document.getElementById('allocation-section').classList.remove('hidden');
}


function showCustomAlert(message) {
    const alertBox = document.createElement('div');
    alertBox.className = 'fixed top-4 right-4 bg-red-500 text-white p-3 rounded-md shadow-lg z-50 transition-transform transform-gpu duration-300 ease-out translate-x-full';
    alertBox.textContent = message;
    document.body.appendChild(alertBox);

    // Show the alert
    setTimeout(() => {
        alertBox.classList.remove('translate-x-full');
    }, 10); // Small delay for transition to work

    // Hide and remove after 3 seconds
    setTimeout(() => {
        alertBox.classList.add('translate-x-full');
        alertBox.addEventListener('transitionend', () => alertBox.remove());
    }, 3000);
}


// Bind event listeners to process and clear buttons (if not already done via HTML onclick)
document.getElementById('process-btn').onclick = processAllFiles;
document.getElementById('clear-all-btn').onclick = clearAll;
// The tab switching logic is already in the DOMContentLoaded block

// Initialize the display for the first time
initializeAllocation();

</script>
